#include <pcap.h>
#include <zstd.h>
#include <fstream>
#include <vector>
#include <iostream>
#include <cstdlib>
#include <ctime>

std::vector<uint8_t> decompressZstdFile(const std::string& filename) {
    std::ifstream file(filename, std::ios::binary);
    if (!file) throw std::runtime_error("Failed to open input file");

    file.seekg(0, std::ios::end);
    size_t compressed_size = file.tellg();
    file.seekg(0);

    std::vector<uint8_t> compressed_data(compressed_size);
    file.read(reinterpret_cast<char*>(compressed_data.data()), compressed_size);

    unsigned long long const decompressed_bound = ZSTD_getFrameContentSize(compressed_data.data(), compressed_size);
    if (decompressed_bound == ZSTD_CONTENTSIZE_ERROR || decompressed_bound == ZSTD_CONTENTSIZE_UNKNOWN)
        throw std::runtime_error("Invalid or unknown compressed size");

    std::vector<uint8_t> decompressed_data(decompressed_bound);
    size_t result = ZSTD_decompress(decompressed_data.data(), decompressed_bound, compressed_data.data(), compressed_size);

    if (ZSTD_isError(result)) {
        throw std::runtime_error("Decompression failed: " + std::string(ZSTD_getErrorName(result)));
    }

    return decompressed_data;
}

void compressToZstdFile(const std::string& filename, const std::vector<uint8_t>& data, int compressionLevel = 3) {
    size_t bound = ZSTD_compressBound(data.size());
    std::vector<uint8_t> compressed(bound);

    size_t compressed_size = ZSTD_compress(compressed.data(), bound, data.data(), data.size(), compressionLevel);
    if (ZSTD_isError(compressed_size)) {
        throw std::runtime_error("Compression failed: " + std::string(ZSTD_getErrorName(compressed_size)));
    }

    std::ofstream outfile(filename, std::ios::binary);
    if (!outfile) throw std::runtime_error("Failed to open output file");
    outfile.write(reinterpret_cast<const char*>(compressed.data()), compressed_size);
}

int main(int argc, char* argv[]) {
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <input.pcap.zst> <output.pcap.zst>\n";
        return 1;
    }

    const std::string input_zst = argv[1];
    const std::string output_zst = argv[2];

    try {
        auto raw_pcap = decompressZstdFile(input_zst);

        char errbuf[PCAP_ERRBUF_SIZE];
        pcap_t* input_handle = pcap_open_offline_with_tstamp_precision(
            reinterpret_cast<const char*>(raw_pcap.data()), PCAP_TSTAMP_PRECISION_MICRO, errbuf
        );

        if (!input_handle) {
            std::cerr << "Error opening decompressed pcap buffer: " << errbuf << '\n';
            return 1;
        }

        // Setup output dumper (writing to a memory buffer)
        int linktype = pcap_datalink(input_handle);
        pcap_t* dead_handle = pcap_open_dead(linktype, 65535);
        std::vector<uint8_t> out_buf;
        FILE* memstream = open_memstream(reinterpret_cast<char**>(&out_buf), nullptr);
        pcap_dumper_t* dumper = pcap_dump_fopen(dead_handle, memstream);
        if (!dumper) {
            std::cerr << "Failed to create output dumper\n";
            return 1;
        }

        srand(static_cast<unsigned>(time(nullptr)));

        const int max_skip = 5;
        int packets_to_skip = 0;

        struct pcap_pkthdr* header;
        const u_char* data;
        int status;

        while ((status = pcap_next_ex(input_handle, &header, &data)) >= 0) {
            if (packets_to_skip > 0) {
                packets_to_skip--;
                continue;
            }

            bool skip_now = rand() % 5 == 0;
            if (skip_now) {
                packets_to_skip = rand() % (max_skip + 1);
            }

            pcap_dump(reinterpret_cast<u_char*>(dumper), header, data);
        }

        fflush(memstream);
        fclose(memstream);
        pcap_dump_close(dumper);
        pcap_close(input_handle);
        pcap_close(dead_handle);

        compressToZstdFile(output_zst, out_buf);

        std::cout << "Written output to: " << output_zst << '\n';

    } catch (const std::exception& e) {
        std::cerr << "Exception: " << e.what() << '\n';
        return 1;
    }

    return 0;
}
